#!/usr/bin/env bash
#
# disk-rsync-backup.sh
#
# Clone all mounted file systems that live on the system disk
# (the disk that holds /) to another disk, using rsync.
# The destination disk is made bootable with GRUB2.
#
# WARNING:
#   * DESTINATION DISK WILL BE COMPLETELY ERASED.
#   * Filesystem UUIDs for ext[234]/xfs/swap will be duplicated on dest.
#     Do NOT boot with both source and backup disks attached simultaneously.
#
# Requirements: bash, rsync, sfdisk, lsblk, blkid, grub-install (GRUB2), root.
#
# Generated by gpt-5.1-high on 2025-11-18
#
set -euo pipefail

die() { echo "ERROR: $*" >&2; exit 1; }

need() {
  command -v "$1" >/dev/null 2>&1 || die "Required command '$1' not found"
}

usage() {
  echo "Usage: $0 /dev/sdX"
  echo "       where /dev/sdX (or /dev/nvmeXn1, etc.) is the DESTINATION disk."
  exit 1
}

[[ $# -eq 1 ]] || usage
DEST_DISK="$1"

[[ $EUID -eq 0 ]] || die "Must be root"

[[ -b "$DEST_DISK" ]] || die "Destination '$DEST_DISK' is not a block device"

need rsync
need sfdisk
need lsblk
need blkid
need grub-install

# Determine the source disk (disk that contains /)
ROOT_SRC=$(findmnt -no SOURCE /)
[[ "$ROOT_SRC" == /dev/* ]] || die "Root filesystem is not on a plain block device (LVM/RAID on top of root is not supported by this script)"

SRC_PKNAME=$(lsblk -no PKNAME "$ROOT_SRC")
[[ -n "$SRC_PKNAME" ]] || die "Could not determine parent disk of $ROOT_SRC"
SRC_DISK="/dev/$SRC_PKNAME"

[[ -b "$SRC_DISK" ]] || die "Source disk '$SRC_DISK' is not a block device"
[[ "$SRC_DISK" != "$DEST_DISK" ]] || die "Source and destination disks must be different"

# Check disk sizes
SRC_SIZE=$(lsblk -bno SIZE "$SRC_DISK")
DEST_SIZE=$(lsblk -bno SIZE "$DEST_DISK")
if (( DEST_SIZE < SRC_SIZE )); then
  die "Destination disk ($DEST_DISK) is smaller than source disk ($SRC_DISK)"
fi

echo "Source disk      : $SRC_DISK"
echo "Destination disk : $DEST_DISK"
echo

# Collect partitions on source disk that are currently mounted
mapfile -t SRC_PARTS < <(
  lsblk -rpno NAME,TYPE,MOUNTPOINT "$SRC_DISK" |
    awk '$2=="part" && length($3)>0 {print $1 "|" $3}'
)

[[ ${#SRC_PARTS[@]} -gt 0 ]] || die "No mounted partitions found on $SRC_DISK"

echo "The following source partitions will be backed up:"
for line in "${SRC_PARTS[@]}"; do
  IFS="|" read -r part mnt <<<"$line"
  fstype=$(blkid -o value -s TYPE "$part" 2>/dev/null || echo "unknown")
  echo "  $part  mounted on $mnt  (fs: $fstype)"
done
echo
echo "WARNING: ALL DATA on $DEST_DISK WILL BE DESTROYED."
read -r -p "Type 'yes' to continue: " ans
[[ "$ans" == "yes" ]] || die "Aborted by user"

echo
echo "=== Unmounting anything currently mounted from $DEST_DISK ==="
while read -r dev mp; do
  if [[ -n "$mp" ]]; then
    echo "  umount $mp"
    umount -R "$mp" || die "Failed to unmount $mp"
  fi
done < <(lsblk -rpno NAME,MOUNTPOINT "$DEST_DISK" | awk 'length($2)>0')

echo
echo "=== Cloning partition table from $SRC_DISK to $DEST_DISK ==="
TMP_PT=$(mktemp)
sfdisk -d "$SRC_DISK" > "$TMP_PT"
sfdisk "$DEST_DISK" < "$TMP_PT"
rm -f "$TMP_PT"

# Inform the kernel about partition table changes
if command -v partprobe >/dev/null 2>&1; then
  partprobe "$DEST_DISK" || true
fi
if command -v udevadm >/dev/null 2>&1; then
  udevadm settle || true
fi

echo
echo "=== Creating filesystems on destination partitions ==="

# Helper: find destination partition on DEST_DISK with the same PARTNUM as source
dest_part_for() {
  local src_part="$1"
  local pn
  pn=$(lsblk -no PARTNUM "$src_part")
  [[ -n "$pn" ]] || die "Could not get PARTNUM for $src_part"
  lsblk -rpno NAME,TYPE,PARTNUM "$DEST_DISK" |
    awk -v pn="$pn" '$2=="part" && $3==pn {print $1; exit}'
}

# Map source partition -> dest partition
declare -A SRC_TO_DEST
for line in "${SRC_PARTS[@]}"; do
  IFS="|" read -r src_part mnt <<<"$line"
  dest_part=$(dest_part_for "$src_part")
  [[ -n "$dest_part" ]] || die "Could not find matching dest partition for $src_part"
  SRC_TO_DEST["$src_part"]="$dest_part"

  fstype=$(blkid -o value -s TYPE "$src_part" 2>/dev/null || echo "unknown")
  case "$fstype" in
    swap)
      uuid=$(blkid -o value -s UUID "$src_part" 2>/dev/null || true)
      label=$(blkid -o value -s LABEL "$src_part" 2>/dev/null || true)
      echo "Creating swap on $dest_part (for source $src_part)"
      if [[ -n "$uuid" ]]; then
        mkswap -U "$uuid" ${label:+-L "$label"} "$dest_part"
      else
        mkswap ${label:+-L "$label"} "$dest_part"
      fi
      ;;
    ext2|ext3|ext4)
      uuid=$(blkid -o value -s UUID "$src_part" 2>/dev/null || true)
      label=$(blkid -o value -s LABEL "$src_part" 2>/dev/null || true)
      echo "Creating $fstype on $dest_part (for source $src_part)"
      args=(-F)
      [[ -n "$uuid" ]] && args+=(-U "$uuid")
      [[ -n "$label" ]] && args+=(-L "$label")
      mkfs.ext4 "${args[@]}" "$dest_part"
      ;;
    xfs)
      uuid=$(blkid -o value -s UUID "$src_part" 2>/dev/null || true)
      label=$(blkid -o value -s LABEL "$src_part" 2>/dev/null || true)
      echo "Creating xfs on $dest_part (for source $src_part)"
      mkfs.xfs -f "$dest_part"
      [[ -n "$uuid" ]] && xfs_admin -U "$uuid" "$dest_part" >/dev/null 2>&1 || true
      [[ -n "$label" ]] && xfs_admin -L "$label" "$dest_part" >/devnull 2>&1 || true
      ;;
    btrfs)
      label=$(blkid -o value -s LABEL "$src_part" 2>/dev/null || true)
      echo "Creating btrfs on $dest_part (for source $src_part)"
      mkfs.btrfs -f ${label:+-L "$label"} "$dest_part"
      echo "NOTE: btrfs UUID will differ from source."
      ;;
    vfat|fat32|fat16)
      label=$(blkid -o value -s LABEL "$src_part" 2>/dev/null || true)
      echo "Creating FAT filesystem on $dest_part (for source $src_part)"
      mkfs.vfat ${label:+-n "$label"} "$dest_part"
      ;;
    *)
      echo "Skipping unsupported filesystem type '$fstype' on $src_part"
      ;;
  esac
done

echo
echo "=== Rsyncing filesystems ==="

BACKUP_ROOT="/mnt/backup-root"
mkdir -p "$BACKUP_ROOT"

# Find root partition mapping
ROOT_SRC_PART=""
ROOT_DEST_PART=""
for line in "${SRC_PARTS[@]}"; do
  IFS="|" read -r src_part mnt <<<"$line"
  if [[ "$mnt" == "/" ]]; then
    ROOT_SRC_PART="$src_part"
    ROOT_DEST_PART="${SRC_TO_DEST[$src_part]}"
    break
  fi
done
[[ -n "$ROOT_SRC_PART" && -n "$ROOT_DEST_PART" ]] || die "Could not identify root (/) partition"

echo "Mounting destination root: $ROOT_DEST_PART -> $BACKUP_ROOT"
mount "$ROOT_DEST_PART" "$BACKUP_ROOT"

# Rsync root filesystem
echo "Rsyncing / -> $BACKUP_ROOT"
rsync -aAXH --delete --one-file-system \
  --exclude="/dev/*" \
  --exclude="/proc/*" \
  --exclude="/sys/*" \
  --exclude="/tmp/*" \
  --exclude="/run/*" \
  --exclude="/mnt/*" \
  --exclude="/media/*" \
  --exclude="/lost+found" \
  / "$BACKUP_ROOT"

# Now handle non-root, non-swap partitions
for line in "${SRC_PARTS[@]}"; do
  IFS="|" read -r src_part mnt <<<"$line"
  [[ "$mnt" == "/" ]] && continue

  fstype=$(blkid -o value -s TYPE "$src_part" 2>/dev/null || echo "unknown")
  [[ "$fstype" == "swap" ]] && continue

  dest_part="${SRC_TO_DEST[$src_part]}"
  dest_mnt="$BACKUP_ROOT$mnt"
  mkdir -p "$dest_mnt"

  echo "Mounting $dest_part -> $dest_mnt (source $src_part mounted on $mnt)"
  mount "$dest_part" "$dest_mnt"

  echo "Rsyncing $mnt -> $dest_mnt"
  rsync -aAXH --delete --one-file-system "$mnt"/ "$dest_mnt"/
done

echo
echo "=== Installing GRUB bootloader on $DEST_DISK ==="

# For UEFI installs we expect an ESP mounted at /boot/efi in the backup tree
EFI_PRESENT=false
if [[ -d /sys/firmware/efi ]]; then
  EFI_PRESENT=true
fi

if $EFI_PRESENT; then
  if mountpoint -q "$BACKUP_ROOT/boot/efi"; then
    echo "Detected UEFI system; installing GRUB2 (EFI) to $DEST_DISK"
    grub-install \
      --target=x86_64-efi \
      --efi-directory="$BACKUP_ROOT/boot/efi" \
      --boot-directory="$BACKUP_ROOT/boot" \
      --removable
  else
    echo "WARNING: UEFI system detected but $BACKUP_ROOT/boot/efi is not a mountpoint."
    echo "GRUB installation for UEFI was skipped. You may need to mount the ESP and run grub-install manually."
  fi
else
  echo "Detected BIOS system; installing GRUB2 (BIOS) to $DEST_DISK"
  grub-install \
    --target=i386-pc \
    --boot-directory="$BACKUP_ROOT/boot" \
    --recheck \
    "$DEST_DISK"
fi

echo
echo "=== Syncing and unmounting destination filesystems ==="
sync

# Unmount in reverse order (deepest paths first)
if mount | grep -q "^.* on $BACKUP_ROOT"; then
  while read -r mp; do
    echo "  umount $mp"
    umount "$mp" || die "Failed to unmount $mp"
  done < <(mount | awk -v p="$BACKUP_ROOT" '$3 ~ "^"p {print $3}' | sort -r)
fi

echo
echo "Backup complete."

echo "NOTE:"
echo "  * The backup disk $DEST_DISK should now be bootable."
echo "  * For ext/xfs/swap filesystems, UUIDs were cloned; do not boot with"
echo "    both source and backup disks attached at the same time."
echo "  * Test the backup by booting from the destination disk (e.g. via BIOS/UEFI boot menu)."
```

# The End
exit 0
